// Kiren Express Compatibility Layer
// Drop-in replacement for Express.js

function createApp() {
  var routes = [];
  var middlewares = [];

  var app = {
    // Middleware registration
    use: function(pathOrMiddleware) {
      var handlers = Array.prototype.slice.call(arguments, 1);

      if (typeof pathOrMiddleware === 'function') {
        middlewares.push({ path: null, handler: pathOrMiddleware });
      } else if (typeof pathOrMiddleware === 'string') {
        for (var i = 0; i < handlers.length; i++) {
          var handler = handlers[i];
          if (handler && handler.routes) {
            // It's a router - mount its routes
            for (var j = 0; j < handler.routes.length; j++) {
              var route = handler.routes[j];
              routes.push({
                method: route.method,
                path: pathOrMiddleware + route.path,
                handlers: route.handlers
              });
            }
          } else if (typeof handler === 'function') {
            middlewares.push({ path: pathOrMiddleware, handler: handler });
          }
        }
      }
      return app;
    },

    get: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      routes.push({ method: 'GET', path: path, handlers: handlers });
      return app;
    },
    post: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      routes.push({ method: 'POST', path: path, handlers: handlers });
      return app;
    },
    put: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      routes.push({ method: 'PUT', path: path, handlers: handlers });
      return app;
    },
    delete: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      routes.push({ method: 'DELETE', path: path, handlers: handlers });
      return app;
    },

    listen: function(port, callback) {
      var server = { port: port };

      function fetchHandler(req) {
        var urlObj = new URL("http://localhost" + req.url);
        var pathname = urlObj.pathname;
        var method = req.method || 'GET';

        // Build request object
        var expressReq = {
          method: method,
          url: req.url,
          path: pathname,
          query: {},
          params: {},
          headers: req.headers || {},
          cookies: {},
          body: null
        };

        expressReq.get = function(name) {
          return expressReq.headers[name.toLowerCase()];
        };

        // Parse query string
        urlObj.searchParams.forEach(function(value, key) {
          expressReq.query[key] = value;
        });

        // Parse cookies
        var cookieHeader = expressReq.headers['cookie'] || '';
        var cookieParts = cookieHeader.split(';');
        for (var i = 0; i < cookieParts.length; i++) {
          var parts = cookieParts[i].trim().split('=');
          if (parts[0]) expressReq.cookies[parts[0]] = parts[1];
        }

        // Parse body
        if (req.body && (method === 'POST' || method === 'PUT')) {
          try {
            expressReq.body = JSON.parse(req.body);
          } catch (e) {
            expressReq.body = req.body;
          }
        }

        // Build response object
        var responseBody = '';
        var responseStatus = 200;
        var responseHeaders = { 'Content-Type': 'application/json' };
        var responseSent = false;

        var expressRes = {
          statusCode: 200,
          status: function(code) {
            responseStatus = code;
            this.statusCode = code;
            return this;
          },
          set: function(name, value) {
            responseHeaders[name] = value;
            return this;
          },
          header: function(name, value) { return this.set(name, value); },
          setHeader: function(name, value) { responseHeaders[name] = value; },
          json: function(data) {
            responseHeaders['Content-Type'] = 'application/json';
            responseBody = JSON.stringify(data);
            responseSent = true;
            return this;
          },
          send: function(data) {
            if (typeof data === 'object') return this.json(data);
            responseBody = String(data);
            responseSent = true;
            return this;
          },
          end: function(data) {
            if (data) responseBody = data;
            responseSent = true;
            return this;
          }
        };

        // Find matching route
        var matchedRoute = null;
        var params = {};

        for (var i = 0; i < routes.length; i++) {
          var route = routes[i];
          if (route.method !== method) continue;

          var match = matchPath(route.path, pathname);
          if (match) {
            matchedRoute = route;
            params = match.params;
            break;
          }
        }

        expressReq.params = params;

        // Run global middlewares synchronously
        for (var i = 0; i < middlewares.length; i++) {
          var mw = middlewares[i];
          if (mw.path === null || pathname.indexOf(mw.path) === 0) {
            var nextCalled = false;
            var nextFn = function() { nextCalled = true; };
            try {
              mw.handler(expressReq, expressRes, nextFn);
              if (responseSent) break;
            } catch (e) {
              console.error("Middleware error:", e);
            }
          }
        }

        // Run route handlers
        if (matchedRoute && !responseSent) {
          for (var i = 0; i < matchedRoute.handlers.length; i++) {
            var handler = matchedRoute.handlers[i];
            var nextCalled = false;
            var nextFn = function() { nextCalled = true; };
            try {
              handler(expressReq, expressRes, nextFn);
              if (responseSent) break;
            } catch (e) {
              console.error("Route error:", e);
              responseStatus = 500;
              responseBody = JSON.stringify({ error: e.message });
              break;
            }
          }
        }

        // 404 if no route matched
        if (!matchedRoute && !responseSent) {
          responseStatus = 404;
          responseBody = JSON.stringify({ error: 'Not Found' });
        }

        return new Response(responseBody, {
          status: responseStatus,
          headers: responseHeaders
        });
      }

      // Start Kiren server
      Kiren.serve({
        port: port,
        fetch: fetchHandler
      });

      if (callback) callback();
      return server;
    }
  };

  return app;
}

// Path matching
function matchPath(pattern, pathname) {
  var patternParts = pattern.split('/').filter(function(p) { return p; });
  var pathParts = pathname.split('/').filter(function(p) { return p; });

  if (patternParts.length !== pathParts.length) return null;

  var params = {};
  for (var i = 0; i < patternParts.length; i++) {
    var pp = patternParts[i];
    var pathPart = pathParts[i];

    if (pp.charAt(0) === ':') {
      params[pp.slice(1)] = pathPart;
    } else if (pp !== pathPart) {
      return null;
    }
  }

  return { params: params };
}

// Router factory
function Router() {
  return {
    routes: [],
    get: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      this.routes.push({ method: 'GET', path: path, handlers: handlers });
      return this;
    },
    post: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      this.routes.push({ method: 'POST', path: path, handlers: handlers });
      return this;
    },
    put: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      this.routes.push({ method: 'PUT', path: path, handlers: handlers });
      return this;
    },
    delete: function(path) {
      var handlers = Array.prototype.slice.call(arguments, 1);
      this.routes.push({ method: 'DELETE', path: path, handlers: handlers });
      return this;
    }
  };
}

// CORS middleware
function cors(options) {
  options = options || {};
  return function(req, res, next) {
    var origin = options.origin || '*';
    var methods = (options.methods || ['GET', 'POST', 'PUT', 'DELETE']).join(', ');
    var headers = (options.allowedHeaders || ['Content-Type', 'Authorization']).join(', ');

    res.set('Access-Control-Allow-Origin', origin);
    res.set('Access-Control-Allow-Methods', methods);
    res.set('Access-Control-Allow-Headers', headers);

    if (options.credentials) {
      res.set('Access-Control-Allow-Credentials', 'true');
    }

    if (req.method === 'OPTIONS') {
      res.status(204).end();
      return;
    }

    next();
  };
}

// Body parser
function json() {
  return function(req, res, next) { next(); };
}

// Cookie parser
function cookieParser() {
  return function(req, res, next) { next(); };
}

// MIME type mapping
var mimeTypes = {
  // Text
  '.html': 'text/html; charset=utf-8',
  '.htm': 'text/html; charset=utf-8',
  '.css': 'text/css; charset=utf-8',
  '.js': 'text/javascript; charset=utf-8',
  '.mjs': 'text/javascript; charset=utf-8',
  '.json': 'application/json; charset=utf-8',
  '.xml': 'application/xml; charset=utf-8',
  '.txt': 'text/plain; charset=utf-8',
  '.md': 'text/markdown; charset=utf-8',
  '.csv': 'text/csv; charset=utf-8',

  // Images
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.webp': 'image/webp',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.bmp': 'image/bmp',

  // Fonts
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.otf': 'font/otf',
  '.eot': 'application/vnd.ms-fontobject',

  // Audio/Video
  '.mp3': 'audio/mpeg',
  '.wav': 'audio/wav',
  '.ogg': 'audio/ogg',
  '.mp4': 'video/mp4',
  '.webm': 'video/webm',
  '.avi': 'video/x-msvideo',

  // Documents
  '.pdf': 'application/pdf',
  '.zip': 'application/zip',
  '.gz': 'application/gzip',
  '.tar': 'application/x-tar',

  // Other
  '.wasm': 'application/wasm',
  '.map': 'application/json'
};

function getMimeType(filepath) {
  var ext = path.extname(filepath).toLowerCase();
  return mimeTypes[ext] || 'application/octet-stream';
}

// Static file serving middleware
function serveStatic(root, options) {
  options = options || {};
  var index = options.index !== undefined ? options.index : 'index.html';
  var maxAge = options.maxAge || 0;

  // Resolve root to absolute path
  var rootPath = path.resolve(root);

  return function staticMiddleware(req, res, next) {
    // Only serve GET and HEAD requests
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      return next();
    }

    // Get the URL path (remove query string)
    var urlPath = req.path || req.url.split('?')[0];

    // Decode URI and prevent path traversal
    try {
      urlPath = decodeURIComponent(urlPath);
    } catch (e) {
      return next();
    }

    // Security: prevent path traversal attacks
    if (urlPath.indexOf('..') !== -1 || urlPath.indexOf('\0') !== -1) {
      return next();
    }

    // Build the file path
    var filepath = path.join(rootPath, urlPath);

    // Ensure the resolved path is within root
    if (filepath.indexOf(rootPath) !== 0) {
      return next();
    }

    // Check if file exists
    if (!fs.existsSync(filepath)) {
      return next();
    }

    // Get file stats
    var stat;
    try {
      stat = fs.statSync(filepath);
    } catch (e) {
      return next();
    }

    // If directory, try index file
    if (stat.isDirectory) {
      if (index) {
        filepath = path.join(filepath, index);
        if (!fs.existsSync(filepath)) {
          return next();
        }
        stat = fs.statSync(filepath);
      } else {
        return next();
      }
    }

    // Read file content
    var content;
    try {
      content = fs.readFileSync(filepath);
    } catch (e) {
      return next();
    }

    // Set headers
    var mimeType = getMimeType(filepath);
    res.set('Content-Type', mimeType);
    res.set('Content-Length', String(content.length));

    // Cache control
    if (maxAge > 0) {
      res.set('Cache-Control', 'public, max-age=' + maxAge);
    }

    // ETag (simple hash based on size and path)
    var etag = '"' + stat.size + '-' + filepath.length + '"';
    res.set('ETag', etag);

    // Check If-None-Match for caching
    var ifNoneMatch = req.headers['if-none-match'];
    if (ifNoneMatch && ifNoneMatch === etag) {
      res.status(304).end();
      return;
    }

    // Send file
    res.status(200).send(content);
  };
}

// Exports
module.exports = createApp;
module.exports.Router = Router;
module.exports.json = json;
module.exports.cors = cors;
module.exports.cookieParser = cookieParser;
module.exports.static = serveStatic;
